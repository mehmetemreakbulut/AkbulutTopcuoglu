module CodeKataBattle

enum Language { PYTHON, JAVA, C, CPP, CSHARP, JAVASCRIPT, GO, RUST, RUBY }
enum QualityAspect { COMPLEXITY, DUPLICATIONS, MAINTAINABILITY, RELIABILITY, SECURITY, CLEAN_CODE }
abstract sig ScoringCriteria {}

one sig TEST_CASES extends ScoringCriteria {}
one sig TIMELINESS extends ScoringCriteria {}
one sig QUALITY extends ScoringCriteria {}

// Basic types
sig Float extends Int{}
abstract sig Bool {}
one sig TRUE extends Bool {} 
one sig FALSE extends Bool {}


sig Institution{}


sig Email{}
sig User {
    email: one Email,
    password: one String,
    name: one String,
    surname: one String,
}

sig Educator extends User {
    creates: set Tournament,
    contributesTo: set Tournament,
    createsBattle: set Battle,
    institutions: set Institution
}

sig Student extends User {
    registers: set Tournament,
    institution: lone Institution
}

sig Tournament {
    title: one String,
    description: one String,
    registrationDeadline: one DateTime,
    closingTime: lone DateTime,
    hasBattle: set Battle,
    subscribers: set Student,
} {
     registrationDeadline.datetime < closingTime.datetime
}

sig ScoringWeights{
    TEST_CASES: one Int,
    TIMELINESS: one Int,
    QUALITY: one Int
    } {
     TEST_CASES > 0 && TIMELINESS > 0 && QUALITY>0 && TEST_CASES + TIMELINESS + QUALITY = 100
    }
	
sig Team {
    teamName: one String,
    hasMember: some Student,
    submits: lone Submission
}

sig Battle {
    title: one String,
    codeKata: one CodeKata,
    minStudentsPerGroup: one Int,
    maxStudentsPerGroup: one Int,
    registrationDeadline: one DateTime,
    submissionDeadline: one DateTime,
    isOngoing: Bool,
    allowedLanguages: some Language,
    teams: set Team,
    scoringWeights: one ScoringWeights,
    manualScoringEnabled: one Bool,
    battleRepositoryUrl: lone String,
} {
  registrationDeadline.datetime < submissionDeadline.datetime &&
  minStudentsPerGroup<=maxStudentsPerGroup &&
  minStudentsPerGroup>=0 &&
  maxStudentsPerGroup>=0 
 }

sig Code{}
sig Submission{
code: one Code,
repositoryUrl: one String,
commitTime: one DateTime,
score: lone BattleScore
}

sig BattleScore {
    testCasesScore: one Int,
    timelinessScore: one Int,
    qualityScore: one Int,
    manualScore: lone Int,
    totalScore: one Int
} {
   totalScore = calculateBattleScore[testCasesScore, timelinessScore, qualityScore]
}

fun calculateBattleScore(tc: Int, timeliness: Int, quality: Int): Int {
    tc + timeliness + quality
}

sig CodeKata {
    description: one String,
    testCases: some language -> one TestCase,
    buildScripts: some language -> one BuildScript
}

sig TestCase {}

sig BuildScript {}

// Simplified DateTime, to compare easily
sig DateTime {
datetime : one Int } {datetime >= 0}

sig SandBoxEnvironment{}

// Relationships and constraints


//All users are either educator or student
fact AllUsersAreEitherEducatorOrStudent {
    all u: User |
        (u in Educator and u not in Student) or (u in Student and u not in Educator)
}


//each users has unique email
fact EmailsAreUnique{
no disjoint u1, u2: User | u1.email = u2.email
}

// Each team must be associated with a battle and have members within the specified group size constraints.
fact TeamsWithinGroupSizeConstraints {
    all t: Team | let b = t.submits.battle | #t.hasMember >= b.minStudentsPerGroup and #t.hasMember <= b.maxStudentsPerGroup
}

//all battles' codekata include test cases for each allowed language in battle
fact AllBattlesIncludeTestCasesForAllowedLanguages {
    all b: Battle | let allowedLanguages = b.allowedLanguages | all l: Language | l in allowedLanguages implies l in b.codeKata.testCases && l in b.codeKata.buildScripts
}

// Every tournament is created by exactly one educator
fact AllTournamentsAreCreatedByOneEducator {
    all t: Tournament | one e: Educator | e.creates = t
}

// Every tournament is contributed to by at least one educator which is the creator of the tournament
fact AllTournamentsAreContributedToByCreator {
    all t: Tournament | let creator = t.creates | creator in t.contributesTo
}

// Every battle is created by exactly one educator
fact AllBattlesAreCreatedByOneEducator {
    all b: Battle | one e: Educator | e.createsBattle = b
}

// Every battle is associated with exactly one tournament
fact AllBattlesAreAssociatedWithOneTournament {
    all b: Battle | one t: Tournament | t.hasBattle = b
}

// Every educator can create battles only for tournaments they contribute to
fact EducatorsCanCreateBattlesOnlyForTournamentsTheyContributeTo {
    all e: Educator, b: Battle | b in e.createsBattle implies b in e.contributesTo.hasBattle
}

// Unique battle titles within a tournament
fact UniqueBattleTitlesWithinTournament {
    all t: Tournament | no disjoint b1, b2: t.hasBattle | b1.title = b2.title
}

// Unique tournament titles
fact UniqueTournamentTitles {
    no disjoint t1, t2: Tournament | t1.title = t2.title
}

// Unique team names within a battle
fact UniqueTeamNamesWithinBattle {
    all b: Battle | no disjoint t1, t2: b.teams | t1.teamName = t2.teamName
}


// A student's submission must be their own work and associated with a team that is part of a battle.
fact UniqueSubmissionRepositoryUrlWithinBattle {
    all b: Battle | no disjoint t1, t2: b.teams | t1.submits.repositoryUrl = t2.submits.repositoryUrl
}

// A student can only register for a tournament once
fact StudentTournamentRegistrations {
    all s: Student | no disjoint t1, t2: s.registers | t1 = t2
}

// A student can only be part of one team per battle
fact StudentTeamRegistrations {
    all s: Student | no disjoint t1, t2: s.hasMember | t1 = t2
}


// Students can only be part of teams for battles in tournaments they have registered for.
fact StudentTeamRegistrations {
    all s: Student | all t: s.registers | let battles = t.hasBattle |
    all team: Team | s in team.hasMember implies team in battles.participants
}

//Only battles with ongoing status can be registered for
fact OnlyOngoingBattlesCanBeRegisteredFor {
    all t: Tournament | let battles = t.hasBattle |
    all b: battles | b.isOngoing = TRUE implies b in t.hasBattle
}

// Battles can be created after Tournament registration deadline
fact BattlesWithinTournamentDeadline {
    all t: Tournament, b: t.hasBattle | b.registrationDeadline.datetime > t.registrationDeadline.datetime
 
}
// Battles can be created before Tournament closing time
fact BattlesWithinTournamentClosingTime {
    all t: Tournament, b: t.hasBattle | t.closingTime != None && b.registrationDeadline.datetime < t.closingTime.datetime
}

fact ManualScoreConstraint {
    all bs: BattleScore |
        bs.manualScore != none Int => bs.manualScore >= 0 && bs.manualScore <= 10
}

fact ScoreWithinWeightRange {
    all b: Battle |
        let weights = b.scoringWeights |
            b.testCasesScore >= 0 && b.testCasesScore <= weights.TEST_CASES &&
            b.timelinessScore >= 0 && b.timelinessScore <= weights.TIMELINESS &&
            b.qualityScore >= 0 && b.qualityScore <= weights.QUALITY
}


fact CalculateBattleScore {
    all bs: BattleScore |
        let result = 0 |
        addManualScoreIfExist[bs, result]
}

pred addManualScoreIfExist(bs: BattleScore, result: Int) {
    some bs.manualScore =>
        result = bs.testCasesScore + bs.timelinessScore + bs.qualityScore + bs.manualScore
    else
        result = bs.testCasesScore + bs.timelinessScore + bs.qualityScore
}


// a student's point from tournament is the sum of points from submissions of team he is part of submitted to battles finished in tournament
// The system shall update the tournament leaderboard at the end of each battle.

pred studentRegistersForTournament[s: Student, t: Tournament] {
    s not in t.subscribers and
    t.registrationDeadline.datetime > DateTime.now().datetime and
    s.registers = s.registers + t
}


pred educatorCreatesTournament[e: Educator, t: Tournament, title: String, desc: String, regDeadline: DateTime] {
    t not in Tournament and
    t.title = title and
    t.description = desc and
    t.registrationDeadline = regDeadline and
    e.creates = e.creates + t
}

pred studentJoinsTeam[s: Student, t: Team] {
    s not in t.hasMember and
    #t.hasMember < t.submits.battle.maxStudentsPerGroup and
    t.hasMember = t.hasMember + s
}

pred studentCreatesTeam[s: Student, b: Battle, newTeam: Team] {
    newTeam not in Team and
    newTeam.hasMember = s and
    b.teams = b.teams + newTeam
}

pred educatorCreatesBattle[e: Educator, t: Tournament, b: Battle, title: String] {
    b not in Battle and
    b.title = title and
    e.createsBattle = e.createsBattle + b and
    t.hasBattle = t.hasBattle + b
}

pred setBattleParameters[e: Educator, b: Battle, minSize: Int, maxSize: Int, regDeadline: DateTime, subDeadline: DateTime] {
    e in b.creates and
    b.minStudentsPerGroup = minSize and
    b.maxStudentsPerGroup = maxSize and
    b.registrationDeadline = regDeadline and
    b.submissionDeadline = subDeadline
}

pred studentSubmitsCode[s: Student, t: Team, sub: Submission, repoUrl: String, commitTime: DateTime] {
    s in t.hasMember and
    sub not in Submission and
    sub.repositoryUrl = repoUrl and
    sub.commitTime = commitTime and
    t.submits = sub
}


pred educatorScoresSubmission[e: Educator, sub: Submission, score: Int] {
    e in sub.submits.battle.creates and
    sub.submits.battle.manualScoringEnabled = TRUE and
    sub.score.manualScore = score
}

pred updateTournamentLeaderboard[t: Tournament] {
    t.isOngoing = FALSE and
    all s: t.subscribers |
        t.tournamentScores[s] = sum b: s.registers.hasBattle | b.teams.hasMember = s | b.score.totalScore
}

pred educatorEditsTournament[e: Educator, t: Tournament, newTitle: String, newDesc: String, newRegDeadline: DateTime] {
    e in t.creates and
    t.title = newTitle and
    t.description = newDesc and
    t.registrationDeadline = newRegDeadline
}




// Assertions

// Assert that students can commit code and trigger automated testing
assert studentsCommitAndTriggerTesting {
    all s: Student, t: s.registers.hasBattle.teams, sub: t.submits |
        sub.repositoryUrl != none and sub.commitTime != none
    // This assertion checks that students in teams have submissions with repository URLs and commit times
}

// Assert that battle scores are automatically updated
assert battleScoresAutomaticallyUpdated {
    all b: Battle, t: b.teams, sub: t.submits |
        sub.score.totalScore = calculateBattleScore[sub.score.testCasesScore, sub.score.timelinessScore, sub.score.qualityScore, sub.score.manualScore]
    // This assertion checks that the total score of each submission is correctly calculated
}

// Assert that educators can manually score submissions
assert educatorsCanManuallyScore {
    all b: Battle | b.manualScoringEnabled = TRUE implies
        all t: b.teams, s: t.submits.score | s.manualScore != none
    // This assertion checks that manual scoring is enabled and scores are provided for battles where it's enabled
}

// Assert that final battle ranks are determined after evaluations
assert finalBattleRanksDetermined {
    all b: Battle | let scores = b.teams.submits.score.totalScore |
        all disj t1, t2: b.teams | let s1 = t1.submits.score, s2 = t2.submits.score |
            s1.totalScore > s2.totalScore implies Rank[t1] < Rank[t2]
    // This assertion assumes a 'Rank' function to check the final ranks based on total scores
}

// Assert that students receive notifications for new tournaments and updates
assert studentsReceiveNotifications {
    all s: Student, t: Tournament | 
        t in s.registers implies t.title in Notifications[s]
    // This assertion assumes a 'Notifications' function that keeps track of notifications received by students
}

// Assert that students can view their rankings on their profiles
assert studentsCanViewRankings {
    all s: Student, t: s.registers | 
        Ranking[s, t] != none
    // This assertion assumes a 'Ranking' function that returns the ranking of a student in a tournament
}

// Run command for student registering for a tournament
run studentRegistersForTournament for 4 but 2 Student, 2 Tournament

// Run command for educator creating a new tournament
run educatorCreatesTournament for 4 but 2 Educator, 2 Tournament

// Run command for student joining a team
run studentJoinsTeam for 4 but 2 Student, 2 Team

// ... and so on for other predicates

// Run command for a combination of actions (e.g., student creates a team and then submits code)
run {
    some s: Student, b: Battle, newTeam: Team | studentCreatesTeam[s, b, newTeam]
    some s: Student, t: newTeam, sub: Submission, repoUrl: String, commitTime: DateTime | studentSubmitsCode[s, t, sub, repoUrl, commitTime]
} for 6 but 3 Student, 2 Team, 2 Submission, 2 Battle

// Check command for assertions (if you have any)

check studentsCommitAndTriggerTesting for 4 but 2 Student, 2 Team, 2 Submission, 2 Battle
check battleScoresAutomaticallyUpdated for 4 but 2 Student, 2 Team, 2 Submission, 2 Battle
check educatorsCanManuallyScore for 4 but 2 Student, 2 Team, 2 Submission, 2 Battle
check finalBattleRanksDetermined for 4 but 2 Student, 2 Team, 2 Submission, 2 Battle
check studentsReceiveNotifications for 4 but 2 Student, 2 Team, 2 Submission, 2 Battle
check studentsCanViewRankings for 4 but 2 Student, 2 Team, 2 Submission, 2 Battle



    

